Акроним SOLID:

S: Single Responsibility Principle (Принцип единственной ответственности).
   - Определите, какие задачи и ответственности несет класс.
   - Проверьте, что класс отвечает только за одну задачу или аспект функциональности.
   - Если класс выполняет несколько различных задач, разделите его на отдельные классы,
     каждый из которых отвечает только за одну задачу.

O: Open-Closed Principle (Принцип открытости-закрытости).
   - Определите, насколько класс открыт для расширения новыми функциями.
   - Проверьте, что класс можно расширить без изменения его исходного кода.
   - Если класс не соответствует этому принципу, примените паттерны проектирования, 
     такие как стратегия или адаптер, чтобы обеспечить его расширяемость.

L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
    - Убедитесь, что классы, производные от базового класса, 
      могут быть использованы вместо него без нарушения корректности программы.
    - Проверьте, что классы-наследники не изменяют поведение базового класса, а только расширяют
      или переопределяют его функциональность. 

I: Interface Segregation Principle (Принцип разделения интерфейса).
     - Убедитесь, что интерфейсы, реализуемые классом, являются независимыми и содержат только необходимые методы.
     - Проверьте, что класс не зависит от методов, которые он не использует.
     - Если класс реализует "толстый" интерфейс, разделите его на несколько более узких интерфейсов.

D: Dependency Inversion Principle (Принцип инверсии зависимостей).
     - Проверьте, что класс зависит от абстракций, а не от конкретных реализаций.
     - Убедитесь, что класс не создает экземпляры зависимых объектов напрямую, а получает их
       через внедрение зависимости (dependency injection).
     - Используйте интерфейсы или абстрактные классы для определения зависимостей класса.


public class User{
	private String surname;
    private String firstname;
	private String patronymic;

	public User(String surname, String firstname, String patronymic) {
		this.surname = surname;
		this.firstname = firstname;
		this.patronymic = patronymic;
	}

	public void setSurname(String surname) {
		this.surname = surname;
	}

	public void setFirstname(String firstname) {
		this.firstname = firstname;
	}

	public void setPatronymic(String patronymic) {
		this.patronymic = patronymic;
	}

	public String getSurname(){
		return surname;
	}
	
	public String getFirstname(){
		return firstname;
	}
	
	public String getPatronymic(){
		return patronymic;
	}

	@Override
	public String toString() {
		return "User{" +
				"surname='" + surname + '\'' +
				", firstname='" + firstname + '\'' +
				", patronymic='" + patronymic + '\'' +
				'}';
	}
}

1. Хранит минимальные атрибуты пользователя - ФИО,данный класс соответствует
   приципу единственной ответственности.
2. Данный класс можно расширить без изменения его исходного кода,данный класс соответствует
   приципу открытости/закрытости.
3. Производные от User классы имеют ФИО и могут быть использованы вместо 
   него без нарушения корректности программы и не изменяют поведение класса User,
   данный класс соответствует приципу подстановки Барбары Лисков.
4. Класс User содержат только необходимые методы, которые используются для реализации хранения 
   актуальной информации о ФИО пользователя,данный класс соответствует приципу разделения интерфейса.
5. Класс User не зависит ни от одного класса, данный класс соответствует приципу инверсии зависимостей.
   класс User полность соответствует принципам SOLID.
